------------------------------------------------------
Core Technologies
------------------------------------------------------
Backend Framework: Spring Boot
Language: Java 17
Database: PostgreSQL
Authentication: Spring Security with JWT (JSON Web Tokens)
Asynchronous Operations: RabbitMQ for message queuing
Caching & Locking: Redis with Redisson for distributed locking to prevent concurrent booking issues.
Scheduling: Spring Scheduler for periodic tasks.
API: RESTful APIs built with Spring Web.

------------------------------------------------------
1. User Management and Authentication
------------------------------------------------------
Endpoints: The AuthController exposes endpoints for user registration (/api/auth/register) and login (/api/auth/login).
Logic: The AuthService handles the business logic. When a user registers, their details are saved to the database via UserRepository. Passwords are encrypted before saving. Upon successful login, a JWT is generated by JwtTokenProvider.
Security: SecurityConfig defines the security rules, specifying which endpoints are public (like login/register) and which are protected. The JwtAuthenticationFilter intercepts incoming requests, validates the JWT from the Authorization header, and sets the user's authentication context.
Entities: The User entity represents both patients and doctors, distinguished by a Role enum.

------------------------------------------------------
2. Doctor Schedule and Slot Generation
------------------------------------------------------
Scheduling: The system likely has a scheduled task (AppointmentScheduler) that runs periodically (e.g., daily or weekly).
Logic: This scheduler triggers the SlotGenerationService. This service reads the DoctorSchedule for each doctor, which defines their availability (e.g., Monday 9 AM - 5 PM).
Slot Creation: Based on the schedule, the service generates AppointmentSlot entities for future dates and saves them to the database. Each slot represents a bookable time frame (e.g., 15-30 minutes). These slots are initially marked as AVAILABLE.

------------------------------------------------------
3. Appointment Booking
------------------------------------------------------
API Endpoint: A patient, after logging in, can fetch available slots (likely through an endpoint in AppointmentController). To book, they would call an endpoint like POST /api/appointments/book.
Concurrency Handling: The AppointmentService handles the booking logic. To prevent the same slot from being booked by multiple users simultaneously, it uses a distributed lock from Redisson on the slot ID. This ensures that only one booking request for a specific slot is processed at a time.
Asynchronous Processing: Instead of processing the booking synchronously, the AppointmentService publishes a message to a RabbitMQ queue (e.g., appointment.booking.queue). This message contains the necessary details like patient ID and slot ID. This makes the API response faster and the system more resilient.
Queue Consumer: The AppointmentBookingConsumer listens to this queue. When it receives a message, it performs the actual booking:
It re-verifies the slot's availability.
It creates a new Appointment record, linking the patient, doctor, and slot.
It updates the AppointmentSlot status to BOOKED.
It saves the new appointment and updates the slot in the database within a single transaction.

------------------------------------------------------
4. Notifications
------------------------------------------------------
Trigger: After an appointment is successfully booked (or cancelled/rescheduled), the system sends a notification.
Service: The NotificationService is responsible for this. It can be called from the AppointmentBookingConsumer after a successful booking.
Mechanism: The service likely sends an email to the patient with the appointment details. It uses the spring-boot-starter-mail dependency for this. It might also persist notification details in the NotificationQueue entity to track delivery status.

------------------------------------------------------
5. Viewing and Managing Appointments
------------------------------------------------------
Endpoints: AppointmentController provides endpoints for users to view their appointments (e.g., /api/appointments/my-appointments).
Logic: The AppointmentService fetches appointment data from the AppointmentRepository based on the logged-in user's ID and role. Patients can see their own appointments, while doctors can see their scheduled appointments.
Entities: The Appointment entity links patients, doctors, and slots. It contains details like appointment date, time, status, and any notes.

------------------------------------------------------
Summary of the Flow
------------------------------------------------------
Admin/Doctor: Sets up doctor schedules.
System (Scheduler): Automatically generates available appointment slots based on these schedules.
Patient: Registers/logs in, gets a JWT.
Patient: Views available slots and sends a request to book one.
System (API): The request is received, a lock is placed on the slot, and a message is sent to a RabbitMQ queue.
System (Consumer): The message is consumed, the appointment is created in the database, and the slot is marked as booked.
System (Notification): A confirmation email is sent to the patient.
Patient/Doctor: Can view their upcoming appointments through the API.